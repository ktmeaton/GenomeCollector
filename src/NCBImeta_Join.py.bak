"""
NCBI Metadata Database Annotator

@author: Katherine Eaton
"""

import argparse
import sqlite3
import datetime
import os
import sys

import NCBImeta_Errors
from NCBImeta_Utilities import table_exists

# Deal with unicode function rename in version 3
if sys.version_info.major == 3:
    unicode = str
    
def flushprint(message):
    print(message)
    sys.stdout.flush()

#-----------------------------------------------------------------------#
#                            Argument Parsing                           #
#-----------------------------------------------------------------------#

parser = argparse.ArgumentParser(description=("NCBImeta Join Tool - Joins accessory tables to an anchor table."),
                                 add_help=True)

mandatory = parser.add_argument_group('mandatory')
bonus = parser.add_argument_group('bonus')

mandatory.add_argument('--database',
                    help='Path to the sqlite database generated by NCBImeta.',
                    type = str,
                    action = 'store',
                    dest = 'dbName',
                    required=True)

mandatory.add_argument('--anchor',
                    help='Table in NCBImeta database to use as an anchor for joining',
                    type = str,
                    action = 'store',
                    dest = 'dbAnchor',
                    required=True)

mandatory.add_argument('--accessory',
                    help='Accessory tables to join to the anchor as space separated str list ex. "BioProject Assembly" ',
                    type = str,
                    action = 'store',
                    dest = 'dbAccessory',
                    required=True)

mandatory.add_argument('--final',
                    help="Name of the final table after the join",
                    type = str,
                    action = 'store',
                    dest = 'dbFinal',
                    required=True)

mandatory.add_argument('--unique',
                    help='List of unique values in anchor table, that could be found in all accessory tables to be joined ex. "Accession BioProject"',
                    type = str,
                    action = 'store',
                    dest = 'dbUnique',
                    required=True)

args = vars(parser.parse_args())

db_name = args['dbName']
db_anchor = args['dbAnchor']
db_accessory_str = args['dbAccessory']
db_accessory_list = db_accessory_str.split(" ")
db_final = args['dbFinal']
unique_header_str = args['dbUnique']
unique_header_list = unique_header_str.split(" ")



#-----------------------------------------------------------------------#
#                           Argument Checking                           #
#-----------------------------------------------------------------------#


#---------------------------Check Database------------------------------#

if os.path.exists(db_name):
    conn = sqlite3.connect(db_name)
    flushprint('\nOpening database: ' + db_name)
else:
    raise NCBImeta_Errors.ErrorDBNotExists(db_name)

# no errors were raised, safe to connect to db
cur = conn.cursor()



#---------------------------Check Tables---------------------------------#

if not table_exists(cur, db_anchor):
    raise NCBImeta_Errors.ErrorTableNotInDB(db_anchor)
for table in db_accessory_list:
    if not table_exists(cur, table):
        raise NCBImeta_Errors.ErrorTableNotInDB(table)




#-----------------------------------------------------------------------#
#                                File Setup                             #
#-----------------------------------------------------------------------#


# get list of column names in anchor table
cur.execute('''SELECT * FROM {}'''.format(db_anchor))
db_col_names = [description[0] for description in cur.description]

# Check to make sure the unique header is present in the anchor table
for unique_header in unique_header_list:
    if unique_header not in db_col_names:
        flushprint("Column not in DB: " + unique_header + ".")
        raise NCBImeta_Errors.ErrorEntryNotInDB(unique_header)

# get list of column names in accessory tables
for table in db_accessory_list:
   cur.execute('''SELECT * FROM {}'''.format(table))
   for header in [description[0] for description in cur.description]:
       db_col_names.append(header)


#-----------------------------------------------------------------------#
#                              Join Tables                              #
#-----------------------------------------------------------------------#

# Get the unique values from the anchor table
query = '''SELECT {0} FROM {1}'''.format(",".join(unique_header_list), db_anchor)
cur.execute(query)
fetch_records = cur.fetchall()

for unique_values in fetch_records:
    unique_values = list(unique_values)
    if None in unique_values: unique_values.remove(None)
    # search for this value in each accessory table
    for table in db_accessory_list:
        print(table)
        # Get list of each column
        cur.execute(''' SELECT * FROM {}'''.format(table))
        table_col_names = [description[0] for description in cur.description]
        # Iterate through each potential unique value
        match_found=False
        match_column = ""
        for uniq_val in unique_values:
            print(uniq_val)
            # Iterate through each column
            for table_col in table_col_names:
                cur.execute('''SELECT {0} FROM {1}'''.format(table_col, table))
                #print(table_col)
                table_col_vals = cur.fetchall()
                # Search through every value for a match
                for val in table_col_vals:
                    if type(val[0]) == int: val=str(val[0])
                    elif type(val[0]) == unicode: val=val[0].encode('utf-8')
                    
                    # If it's a match, store the value, and set the boolean flag
                    if val == uniq_val: 
                        match_found=True
                        match_column=table_col
                        continue

                # Stop searching
                if match_found: continue
            if match_found: continue

        print(match_found, match_column)
                



#-----------------------------------------------------------------------#
#                                    Cleanup                            #
#-----------------------------------------------------------------------#
# Commit changes
conn.commit()
flushprint("Closing database: " + db_name)
cur.close()
